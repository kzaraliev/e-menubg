import { NextResponse } from "next/server";
import { sendOpenAi } from "@/libs/gpt";
import { getUIText } from "@/libs/uiTranslations";

// Simple in-memory cache for cost optimization
const responseCache = new Map();
const CACHE_TTL = 10 * 60 * 1000; // 10 minutes cache

export async function POST(req) {
  try {
    const { message, menuData, currentLanguage = 'bg' } = await req.json();

    if (!message || !menuData) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    const { restaurant, categories } = menuData;

    // Create cache key for cost optimization
    const cacheKey = `${restaurant._id}-${message.toLowerCase().trim()}-${currentLanguage}`;
    
    // Pre-filter obvious non-food questions to save API costs
    const isOffTopic = checkIfOffTopic(message, currentLanguage);
    if (isOffTopic) {
      console.log("üö´ Off-topic question blocked - saved API cost!");
      const offTopicResponse = getUIText('aiOffTopic', currentLanguage);
      
      return NextResponse.json({
        response: offTopicResponse,
        recommendations: []
      });
    }

    // Check cache first to save money
    const cached = responseCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
      console.log("üí∞ Using cached response - saved API cost!");
      return NextResponse.json(cached.data);
    }

    // Prepare ultra-minimal menu data for AI analysis (aggressive token optimization)
    const menuForAI = categories.map(category => ({
      c: category.name, // cat -> c
      i: category.products
        .filter(product => product.isAvailable) // Only send available items
        .map(product => {
          // Create compact array format: [name, price, size, description_snippet, flags, id]
          const flags = 
            (product.isVegetarian ? 'v' : '') +
            (product.isVegan ? 'g' : '') +
            (product.isSpicy ? 'h' : '') +
            (product.isPopular ? 'p' : '');
          
          return [
            product.name,
            product.priceBGN,
            product.size || '',
            product.description?.substring(0, 50) || '', // Even shorter description
            flags,
            product._id,
            product.preparationTime || 0
          ];
        })
    }));

    // Create system prompt in the appropriate language
    const systemPrompt = createSystemPrompt(restaurant, menuForAI, currentLanguage);
    
    // Create messages for OpenAI
    const messages = [
      {
        role: "system",
        content: systemPrompt
      },
      {
        role: "user",
        content: message
      }
    ];

    // Get AI response with balanced optimization (accuracy + cost)
    const aiResponse = await sendOpenAi(messages, "ai-assistant", 200, 0.5);

    if (!aiResponse) {
      console.error("OpenAI API call failed - using fallback logic");
      // Use intelligent fallback logic when AI is not available
      const fallbackResult = getFallbackRecommendations(message, menuData, currentLanguage);
      
      return NextResponse.json({
        response: fallbackResult.response,
        recommendations: fallbackResult.recommendations
      });
    }

    // Parse AI response to extract recommendations
    const { response, productIds } = parseAIResponse(aiResponse);

    // Find recommended products
    const recommendations = [];
    if (productIds && productIds.length > 0) {
      categories.forEach(category => {
        category.products.forEach(product => {
          if (productIds.includes(product._id)) {
            recommendations.push(product);
          }
        });
      });
    }

    const finalResponse = {
      response,
      recommendations: recommendations.slice(0, 5) // Limit to 5 recommendations
    };

    // Cache successful responses to save money on future identical queries
    responseCache.set(cacheKey, {
      data: finalResponse,
      timestamp: Date.now()
    });

    // Clean old cache entries periodically
    if (responseCache.size > 1000) {
      const oldEntries = Array.from(responseCache.entries())
        .filter(([, value]) => Date.now() - value.timestamp > CACHE_TTL);
      oldEntries.forEach(([key]) => responseCache.delete(key));
    }

    return NextResponse.json(finalResponse);

  } catch (error) {
    console.error("AI recommendations error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

function createSystemPrompt(restaurant, menuData) {
  const restaurantName = restaurant.name;
  
  return `–¢–∏ —Å–∏ –∞—Å–∏—Å—Ç–µ–Ω—Ç –∑–∞ –º–µ–Ω—é –Ω–∞ —Ä–µ—Å—Ç–æ—Ä–∞–Ω—Ç ${restaurantName}. –û—Ç–≥–æ–≤–∞—Ä—è–π —Å–∞–º–æ –Ω–∞ –≤—ä–ø—Ä–æ—Å–∏ –∑–∞ —Ö—Ä–∞–Ω–∞/–Ω–∞–ø–∏—Ç–∫–∏.

–ú–ï–ù–Æ: ${JSON.stringify(menuData)}

–§–û–†–ú–ê–¢: i=[–∏–º–µ,—Ü–µ–Ω–∞,—Ä–∞–∑–º–µ—Ä,–æ–ø–∏—Å–∞–Ω–∏–µ,–§–õ–ê–ì–û–í–ï,id,–≤—Ä–µ–º–µ]

–§–õ–ê–ì–û–í–ï –°–ê –ù–ê –ü–û–ó–ò–¶–ò–Ø 5 –í –ú–ê–°–ò–í–ê! –ü–†–û–í–ï–†–Ø–í–ê–ô –ì–ò –ó–ê–î–™–õ–ñ–ò–¢–ï–õ–ù–û:
- –ê–∫–æ –§–õ–ê–ì–™–¢ —Å—ä–¥—ä—Ä–∂–∞ –±—É–∫–≤–∞—Ç–∞ "h" = –õ–Æ–¢–û —è—Å—Ç–∏–µ
- –ê–∫–æ –§–õ–ê–ì–™–¢ —Å—ä–¥—ä—Ä–∂–∞ –±—É–∫–≤–∞—Ç–∞ "p" = –ü–û–ü–£–õ–Ø–†–ù–û —è—Å—Ç–∏–µ  
- –ê–∫–æ –§–õ–ê–ì–™–¢ —Å—ä–¥—ä—Ä–∂–∞ –±—É–∫–≤–∞—Ç–∞ "v" = –í–ï–ì–ï–¢–ê–†–ò–ê–ù–°–ö–û —è—Å—Ç–∏–µ
- –ê–∫–æ –§–õ–ê–ì–™–¢ —Å—ä–¥—ä—Ä–∂–∞ –±—É–∫–≤–∞—Ç–∞ "g" = –í–ï–ì–ê–ù —è—Å—Ç–∏–µ

–ü–†–ò–ú–ï–†: ["–†—É—Å–∫–∞ —Å–∞–ª–∞—Ç–∞",9.99,"300 –≥—Ä.","–æ–ø–∏—Å–∞–Ω–∏–µ","h","id",3] - —Ç—É–∫ —Ñ–ª–∞–≥—ä—Ç –µ "h" –∫–æ–µ—Ç–æ –æ–∑–Ω–∞—á–∞–≤–∞ –õ–Æ–¢–û!

–ö–†–ò–¢–ò–ß–ù–û: –í–∏–Ω–∞–≥–∏ –æ—Ç–≥–æ–≤–∞—Ä—è–π –Ω–∞ –°–™–©–ò–Ø –ï–ó–ò–ö, –Ω–∞ –∫–æ–π—Ç–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –ø–∏—Ç–∞!

–ü—Ä–∞–≤–∏–ª–∞: –ö—Ä–∞—Ç—ä–∫ –æ—Ç–≥–æ–≤–æ—Ä (2-3 –∏–∑—Ä–µ—á–µ–Ω–∏—è). –í–∫–ª—é—á–∏ "RECOMMENDED_IDS: [id1,id2]" –≤ –∫—Ä–∞—è.`;
}

function parseAIResponse(aiResponse) {
  // Look for RECOMMENDED_IDS at the end of the response
  const idPattern = /RECOMMENDED_IDS:\s*\[(.*?)\]/;
  const match = aiResponse.match(idPattern);
  
  let productIds = [];
  let response = aiResponse;

  if (match) {
    // Extract IDs and clean them
    const idString = match[1];
    productIds = idString
      .split(',')
      .map(id => id.trim().replace(/['"]/g, ''))
      .filter(id => id.length > 0);
    
    // Remove the RECOMMENDED_IDS line from the response
    response = aiResponse.replace(idPattern, '').trim();
  }

  return {
    response,
    productIds
  };
}

// Intelligent fallback system when OpenAI is not available
function getFallbackRecommendations(userMessage, menuData) {
  const { categories } = menuData;
  const message = userMessage.toLowerCase();
  
  // Collect all products
  const allProducts = [];
  categories.forEach(category => {
    category.products.forEach(product => {
      allProducts.push({
        ...product,
        categoryName: category.category
      });
    });
  });
  
  let recommendations = [];
  let responseText = "";
  
  // Pattern matching for common queries (balanced accuracy and brevity)
  if (message.includes('–ª—é—Ç–æ') || message.includes('spicy') || message.includes('–æ—Å—Ç—Ä–æ–µ')) {
    recommendations = allProducts.filter(p => p.isSpicy);
    responseText = language === 'bg' 
      ? recommendations.length > 0 
        ? `–ù–∞—à–∏ –ª—é—Ç–∏ —è—Å—Ç–∏—è - –æ—Ç–ª–∏—á–Ω–∏ –∑–∞ –ª—é–±–∏—Ç–µ–ª–∏—Ç–µ –Ω–∞ –ø–∏–∫–∞–Ω—Ç–Ω–æ—Ç–æ:`
        : `–í –º–æ–º–µ–Ω—Ç–∞ –Ω—è–º–∞ –ª—é—Ç–∏ —è—Å—Ç–∏—è –≤ –º–µ–Ω—é—Ç–æ.`
      : recommendations.length > 0
        ? `Our spicy dishes - perfect for spice lovers:`
        : `No spicy dishes currently available.`;
  }
  else if (message.includes('–≤–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω') || message.includes('vegetarian') || message.includes('–≤–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω—Å–∫')) {
    recommendations = allProducts.filter(p => p.isVegetarian);
    responseText = language === 'bg' 
      ? recommendations.length > 0 ? `–í–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω—Å–∫–∏ –æ–ø—Ü–∏–∏:` : `–ù—è–º–∞ –≤–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω—Å–∫–∏ —è—Å—Ç–∏—è –≤ –º–µ–Ω—é—Ç–æ.`
      : recommendations.length > 0 ? `Vegetarian options:` : `No vegetarian dishes available.`;
  }
  else if (message.includes('–≤–µ–≥–∞–Ω') || message.includes('vegan')) {
    recommendations = allProducts.filter(p => p.isVegan);
    responseText = language === 'bg' 
      ? recommendations.length > 0 ? `–í–µ–≥–∞–Ω —è—Å—Ç–∏—è:` : `–ù—è–º–∞ –≤–µ–≥–∞–Ω —è—Å—Ç–∏—è –≤ –º–µ–Ω—é—Ç–æ.`
      : recommendations.length > 0 ? `Vegan dishes:` : `No vegan dishes available.`;
  }
  else if (message.includes('–ø–æ–ø—É–ª—è—Ä–Ω') || message.includes('popular') || message.includes('–ø—Ä–µ–ø–æ—Ä—ä—á–∞–π') || message.includes('recommend')) {
    recommendations = allProducts.filter(p => p.isPopular);
    responseText = language === 'bg' 
      ? recommendations.length > 0 ? `–ü–æ–ø—É–ª—è—Ä–Ω–∏ —è—Å—Ç–∏—è - –ª—é–±–∏–º–∏ –Ω–∞ –∫–ª–∏–µ–Ω—Ç–∏—Ç–µ:` : `–í—Å–∏—á–∫–∏ —è—Å—Ç–∏—è —Å–∞ –µ–¥–Ω–∞–∫–≤–æ –¥–æ–±—Ä–∏!`
      : recommendations.length > 0 ? `Popular dishes - customer favorites:` : `All dishes are equally great!`;
  }
  else if (message.includes('–±—ä—Ä–∑') || message.includes('quick') || message.includes('fast') || message.includes('–º–∏–Ω—É—Ç')) {
    recommendations = allProducts.filter(p => p.preparationTime && p.preparationTime <= 10);
    responseText = language === 'bg' ? `–ë—ä—Ä–∑–∏ —è—Å—Ç–∏—è:` : `Quick dishes:`;
  }
  else if (message.match(/–ø–æ–¥\s*(\d+)|under\s*(\d+)|–¥–æ\s*(\d+)/)) {
    const priceMatch = message.match(/(\d+)/);
    const maxPrice = priceMatch ? parseInt(priceMatch[1]) : 20;
    recommendations = allProducts.filter(p => p.price <= maxPrice);
    responseText = language === 'bg' ? `–ü–æ–¥ ${maxPrice} –ª–≤:` : `Under ${maxPrice} BGN:`;
  }
  else if (message.includes('—Å–∞–ª–∞—Ç') || message.includes('salad')) {
    recommendations = allProducts.filter(p => 
      p.name.toLowerCase().includes('—Å–∞–ª–∞—Ç') || 
      p.name.toLowerCase().includes('salad') ||
      p.categoryName.toLowerCase().includes('—Å–∞–ª–∞—Ç')
    );
    responseText = language === 'bg' ? `–°–∞–ª–∞—Ç–∏:` : `Salads:`;
  }
  else if (message.includes('–ø–∏—Ü–∞') || message.includes('pizza')) {
    recommendations = allProducts.filter(p => 
      p.name.toLowerCase().includes('–ø–∏—Ü–∞') || 
      p.name.toLowerCase().includes('pizza') ||
      p.categoryName.toLowerCase().includes('–ø–∏—Ü–∞')
    );
    responseText = language === 'bg' ? `–ü–∏—Ü–∏:` : `Pizzas:`;
  }
  else {
    // Default: show popular items
    recommendations = allProducts.filter(p => p.isPopular).slice(0, 3);
    if (recommendations.length === 0) {
      recommendations = allProducts.slice(0, 3);
    }
    responseText = language === 'bg' ? `–ü—Ä–µ–ø–æ—Ä—ä–∫–∏:` : `Recommendations:`;
  }
  
  // Limit recommendations to 5
  recommendations = recommendations.slice(0, 5);
  
  return {
    response: responseText,
    recommendations: recommendations
  };
}

// Pre-filter function to catch obvious non-food questions and save API costs
function checkIfOffTopic(message) {
  const msg = message.toLowerCase();
  
  // Simple food keywords check (multiple languages)
  const foodWords = [
    // Bulgarian
    '—Ö—Ä–∞–Ω–∞', '—è—Å—Ç–∏–µ', '–º–µ–Ω—é', '–Ω–∞–ø–∏—Ç–∫–∞', '–∫–∞—Ñ–µ', '—á–∞–π', '–ø–∏—Ü–∞', '—Å–∞–ª–∞—Ç–∞', '—Ü–µ–Ω–∞', '–ª–≤',
    // English  
    'food', 'dish', 'menu', 'drink', 'coffee', 'tea', 'pizza', 'salad', 'price',
    // Slovak
    'jedlo', 'pokrm', 'menu', 'n√°poj', 'k√°va', 'ƒçaj', 'pizza', '≈°al√°t', 'cena',
    // German
    'essen', 'gericht', 'men√º', 'getr√§nk', 'kaffee', 'tee', 'pizza', 'salat', 'preis'
  ];
  
  // Obvious non-food topics (multiple languages)
  const badWords = [
    '—Å—Ç–æ–ª–∏—Ü–∞', '–ø–æ–ª–∏—Ç–∏–∫–∞', '–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞', '–∫–æ–º–ø—é—Ç—ä—Ä', '–≤—Ä–µ–º–µ—Ç–æ', '—Å–ø–æ—Ä—Ç',
    'capital', 'politics', 'math', 'computer', 'weather', 'sport',
    'hlavn√©', 'politika', 'matematika', 'poƒç√≠taƒç', 'poƒçasie', '≈°port'
  ];
  
  const hasFoodWords = foodWords.some(word => msg.includes(word));
  const hasBadWords = badWords.some(word => msg.includes(word));
  
  return hasBadWords && !hasFoodWords;
}

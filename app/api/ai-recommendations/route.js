import { NextResponse } from "next/server";
import { sendOpenAi } from "@/libs/gpt";

// Simple in-memory cache for cost optimization
const responseCache = new Map();
const CACHE_TTL = 10 * 60 * 1000; // 10 minutes cache

export async function POST(req) {
  try {
    const { message, menuData, currentLanguage = 'bg' } = await req.json();

    if (!message || !menuData) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    const { restaurant, categories } = menuData;

    // Create cache key for cost optimization
    const cacheKey = `${restaurant._id}-${message.toLowerCase().trim()}-${currentLanguage}`;
    
    // Check cache first to save money
    const cached = responseCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
      console.log("üí∞ Using cached response - saved API cost!");
      return NextResponse.json(cached.data);
    }

    // Prepare minimal menu data for AI analysis (cost optimization - fewer tokens)
    const menuForAI = categories.map(category => ({
      cat: category.name, // Shortened field names to save tokens
      items: category.products.map(product => ({
        n: product.name,
        d: product.description?.substring(0, 50) || '', // Limit description length
        p: product.priceBGN,
        s: product.size || '',
        a: product.allergens || [],
        veg: product.isVegetarian,
        vgn: product.isVegan,
        hot: product.isSpicy,
        pop: product.isPopular,
        avl: product.isAvailable,
        min: product.preparationTime || null,
        id: product._id
      }))
    }));

    // Create system prompt in the appropriate language
    const systemPrompt = createSystemPrompt(restaurant, menuForAI, currentLanguage);
    
    // Create messages for OpenAI
    const messages = [
      {
        role: "system",
        content: systemPrompt
      },
      {
        role: "user",
        content: message
      }
    ];

    // Get AI response with balanced optimization (accuracy + cost)
    const aiResponse = await sendOpenAi(messages, "ai-assistant", 200, 0.5);

    if (!aiResponse) {
      console.error("OpenAI API call failed - using fallback logic");
      // Use intelligent fallback logic when AI is not available
      const fallbackResult = getFallbackRecommendations(message, menuData, currentLanguage);
      
      return NextResponse.json({
        response: fallbackResult.response,
        recommendations: fallbackResult.recommendations
      });
    }

    // Parse AI response to extract recommendations
    const { response, productIds } = parseAIResponse(aiResponse);

    // Find recommended products
    const recommendations = [];
    if (productIds && productIds.length > 0) {
      categories.forEach(category => {
        category.products.forEach(product => {
          if (productIds.includes(product._id)) {
            recommendations.push(product);
          }
        });
      });
    }

    const finalResponse = {
      response,
      recommendations: recommendations.slice(0, 5) // Limit to 5 recommendations
    };

    // Cache successful responses to save money on future identical queries
    responseCache.set(cacheKey, {
      data: finalResponse,
      timestamp: Date.now()
    });

    // Clean old cache entries periodically
    if (responseCache.size > 1000) {
      const oldEntries = Array.from(responseCache.entries())
        .filter(([, value]) => Date.now() - value.timestamp > CACHE_TTL);
      oldEntries.forEach(([key]) => responseCache.delete(key));
    }

    return NextResponse.json(finalResponse);

  } catch (error) {
    console.error("AI recommendations error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

function createSystemPrompt(restaurant, menuData, language) {
  const restaurantName = restaurant.name;
  
  if (language === 'en') {
    return `You are an AI assistant for ${restaurantName}. Give accurate, concise recommendations.

MENU: ${JSON.stringify(menuData, null, 2)}

IMPORTANT - ANALYZE MENU CAREFULLY:
- "hot": true = SPICY dish
- "veg": true = vegetarian  
- "vgn": true = vegan
- "pop": true = popular

RULES:
1. Answer in 2-3 sentences maximum
2. Always check dish properties accurately
3. If spicy dishes exist (hot: true), recommend them for "spicy" requests
4. Include product IDs at end: "RECOMMENDED_IDS: [id1, id2]"
5. Explain why you recommend the dish

EXAMPLE:
"For spicy - I recommend Caesar Salad! It's marked as spicy and very popular (11.98 BGN).
RECOMMENDED_IDS: [507f1f77bcf86cd799439011]"`;
  }

  // Bulgarian system prompt - balanced for accuracy and cost
  return `–¢–∏ —Å–∏ AI –∞—Å–∏—Å—Ç–µ–Ω—Ç –∑–∞ ${restaurantName}. –î–∞–≤–∞–π —Ç–æ—á–Ω–∏, –∫—Ä–∞—Ç–∫–∏ –ø—Ä–µ–ø–æ—Ä—ä–∫–∏.

–ú–ï–ù–Æ: ${JSON.stringify(menuData, null, 2)}

–í–ê–ñ–ù–û - –ê–ù–ê–õ–ò–ó–ò–†–ê–ô –ú–ï–ù–Æ–¢–û –í–ù–ò–ú–ê–¢–ï–õ–ù–û:
- "hot": true = –õ–Æ–¢O —è—Å—Ç–∏–µ  
- "veg": true = –≤–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω—Å–∫–æ
- "vgn": true = –≤–µ–≥–∞–Ω
- "pop": true = –ø–æ–ø—É–ª—è—Ä–Ω–æ

–ü–†–ê–í–ò–õ–ê:
1. –û—Ç–≥–æ–≤–∞—Ä—è–π –≤ 2-3 –∏–∑—Ä–µ—á–µ–Ω–∏—è –º–∞–∫—Å–∏–º—É–º
2. –í–∏–Ω–∞–≥–∏ –ø—Ä–æ–≤–µ—Ä—è–≤–∞–π —Å–≤–æ–π—Å—Ç–≤–∞—Ç–∞ –Ω–∞ —è—Å—Ç–∏—è—Ç–∞ —Ç–æ—á–Ω–æ
3. –ê–∫–æ –∏–º–∞ –ª—é—Ç–∏ —è—Å—Ç–∏—è (hot: true), –ø—Ä–µ–ø–æ—Ä—ä—á–∞–π –≥–∏ –∑–∞ "–ª—é—Ç–æ"
4. –í–∫–ª—é—á–∏ ID-—Ç–∞ –≤ –∫—Ä–∞—è: "RECOMMENDED_IDS: [id1, id2]"
5. –û–±—è—Å–Ω–∏ –∑–∞—â–æ –ø—Ä–µ–ø–æ—Ä—ä—á–≤–∞—à —è—Å—Ç–∏–µ—Ç–æ

–ü–†–ò–ú–ï–†:
"–ó–∞ –ª—é—Ç–æ - –ø—Ä–µ–ø–æ—Ä—ä—á–≤–∞–º –°–∞–ª–∞—Ç–∞ –¶–µ–∑–∞—Ä! –¢—è –µ –æ–∑–Ω–∞—á–µ–Ω–∞ –∫–∞—Ç–æ –ø–∏–∫–∞–Ω—Ç–Ω–∞ –∏ –µ –º–Ω–æ–≥–æ –ø–æ–ø—É–ª—è—Ä–Ω–∞ (11.98 –ª–≤).
RECOMMENDED_IDS: [507f1f77bcf86cd799439011]"`;
}

function parseAIResponse(aiResponse) {
  // Look for RECOMMENDED_IDS at the end of the response
  const idPattern = /RECOMMENDED_IDS:\s*\[(.*?)\]/;
  const match = aiResponse.match(idPattern);
  
  let productIds = [];
  let response = aiResponse;

  if (match) {
    // Extract IDs and clean them
    const idString = match[1];
    productIds = idString
      .split(',')
      .map(id => id.trim().replace(/['"]/g, ''))
      .filter(id => id.length > 0);
    
    // Remove the RECOMMENDED_IDS line from the response
    response = aiResponse.replace(idPattern, '').trim();
  }

  return {
    response,
    productIds
  };
}

// Intelligent fallback system when OpenAI is not available
function getFallbackRecommendations(userMessage, menuData, language) {
  const { restaurant, categories } = menuData;
  const message = userMessage.toLowerCase();
  
  // Collect all products
  const allProducts = [];
  categories.forEach(category => {
    category.products.forEach(product => {
      allProducts.push({
        ...product,
        categoryName: category.category
      });
    });
  });
  
  let recommendations = [];
  let responseText = "";
  
  // Pattern matching for common queries (balanced accuracy and brevity)
  if (message.includes('–ª—é—Ç–æ') || message.includes('spicy') || message.includes('–æ—Å—Ç—Ä–æ–µ')) {
    recommendations = allProducts.filter(p => p.isSpicy);
    responseText = language === 'bg' 
      ? recommendations.length > 0 
        ? `–ù–∞—à–∏ –ª—é—Ç–∏ —è—Å—Ç–∏—è - –æ—Ç–ª–∏—á–Ω–∏ –∑–∞ –ª—é–±–∏—Ç–µ–ª–∏—Ç–µ –Ω–∞ –ø–∏–∫–∞–Ω—Ç–Ω–æ—Ç–æ:`
        : `–í –º–æ–º–µ–Ω—Ç–∞ –Ω—è–º–∞ –ª—é—Ç–∏ —è—Å—Ç–∏—è –≤ –º–µ–Ω—é—Ç–æ.`
      : recommendations.length > 0
        ? `Our spicy dishes - perfect for spice lovers:`
        : `No spicy dishes currently available.`;
  }
  else if (message.includes('–≤–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω') || message.includes('vegetarian') || message.includes('–≤–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω—Å–∫')) {
    recommendations = allProducts.filter(p => p.isVegetarian);
    responseText = language === 'bg' 
      ? recommendations.length > 0 ? `–í–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω—Å–∫–∏ –æ–ø—Ü–∏–∏:` : `–ù—è–º–∞ –≤–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω—Å–∫–∏ —è—Å—Ç–∏—è –≤ –º–µ–Ω—é—Ç–æ.`
      : recommendations.length > 0 ? `Vegetarian options:` : `No vegetarian dishes available.`;
  }
  else if (message.includes('–≤–µ–≥–∞–Ω') || message.includes('vegan')) {
    recommendations = allProducts.filter(p => p.isVegan);
    responseText = language === 'bg' 
      ? recommendations.length > 0 ? `–í–µ–≥–∞–Ω —è—Å—Ç–∏—è:` : `–ù—è–º–∞ –≤–µ–≥–∞–Ω —è—Å—Ç–∏—è –≤ –º–µ–Ω—é—Ç–æ.`
      : recommendations.length > 0 ? `Vegan dishes:` : `No vegan dishes available.`;
  }
  else if (message.includes('–ø–æ–ø—É–ª—è—Ä–Ω') || message.includes('popular') || message.includes('–ø—Ä–µ–ø–æ—Ä—ä—á–∞–π') || message.includes('recommend')) {
    recommendations = allProducts.filter(p => p.isPopular);
    responseText = language === 'bg' 
      ? recommendations.length > 0 ? `–ü–æ–ø—É–ª—è—Ä–Ω–∏ —è—Å—Ç–∏—è - –ª—é–±–∏–º–∏ –Ω–∞ –∫–ª–∏–µ–Ω—Ç–∏—Ç–µ:` : `–í—Å–∏—á–∫–∏ —è—Å—Ç–∏—è —Å–∞ –µ–¥–Ω–∞–∫–≤–æ –¥–æ–±—Ä–∏!`
      : recommendations.length > 0 ? `Popular dishes - customer favorites:` : `All dishes are equally great!`;
  }
  else if (message.includes('–±—ä—Ä–∑') || message.includes('quick') || message.includes('fast') || message.includes('–º–∏–Ω—É—Ç')) {
    recommendations = allProducts.filter(p => p.preparationTime && p.preparationTime <= 10);
    responseText = language === 'bg' ? `–ë—ä—Ä–∑–∏ —è—Å—Ç–∏—è:` : `Quick dishes:`;
  }
  else if (message.match(/–ø–æ–¥\s*(\d+)|under\s*(\d+)|–¥–æ\s*(\d+)/)) {
    const priceMatch = message.match(/(\d+)/);
    const maxPrice = priceMatch ? parseInt(priceMatch[1]) : 20;
    recommendations = allProducts.filter(p => p.price <= maxPrice);
    responseText = language === 'bg' ? `–ü–æ–¥ ${maxPrice} –ª–≤:` : `Under ${maxPrice} BGN:`;
  }
  else if (message.includes('—Å–∞–ª–∞—Ç') || message.includes('salad')) {
    recommendations = allProducts.filter(p => 
      p.name.toLowerCase().includes('—Å–∞–ª–∞—Ç') || 
      p.name.toLowerCase().includes('salad') ||
      p.categoryName.toLowerCase().includes('—Å–∞–ª–∞—Ç')
    );
    responseText = language === 'bg' ? `–°–∞–ª–∞—Ç–∏:` : `Salads:`;
  }
  else if (message.includes('–ø–∏—Ü–∞') || message.includes('pizza')) {
    recommendations = allProducts.filter(p => 
      p.name.toLowerCase().includes('–ø–∏—Ü–∞') || 
      p.name.toLowerCase().includes('pizza') ||
      p.categoryName.toLowerCase().includes('–ø–∏—Ü–∞')
    );
    responseText = language === 'bg' ? `–ü–∏—Ü–∏:` : `Pizzas:`;
  }
  else {
    // Default: show popular items
    recommendations = allProducts.filter(p => p.isPopular).slice(0, 3);
    if (recommendations.length === 0) {
      recommendations = allProducts.slice(0, 3);
    }
    responseText = language === 'bg' ? `–ü—Ä–µ–ø–æ—Ä—ä–∫–∏:` : `Recommendations:`;
  }
  
  // Limit recommendations to 5
  recommendations = recommendations.slice(0, 5);
  
  return {
    response: responseText,
    recommendations: recommendations
  };
}
